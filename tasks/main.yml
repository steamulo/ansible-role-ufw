---

- name: Update apt-cache if necessary
  apt: update_cache=yes cache_valid_time=3600
  when: not ansible_check_mode

- name: Install ufw packages
  apt: name=ufw state=latest
  when: not ansible_check_mode

- name: Check the current configuration
  shell: ufw status numbered
  register: current_ufw_status
  changed_when: false
  ignore_errors: yes

- name: Set variables
  block:
    - name: Parse current UFW rules
      set_fact:
        ufw_parsed: "{{ current_ufw_status.stdout | community.general.jc('ufw') }}"

    - name: Concatenate and remove duplicates
      set_fact:
        incoming_rules: "{{ ufw_whitelisted_in_ports + ufw_whitelisted_in_ports_extra | unique }}"

- name: Enable/Disable logging if different from playbook value
  block:
    - name: Get current UFW logging status
      set_fact:
        current_ufw_logging: "{{ ufw_parsed.logging | default('disabled') }}"

    - name: Set UFW logging to playbook value if different
      ufw:
        logging: "{{ ufw_logging }}"
      when: not ansible_check_mode and current_ufw_logging != ufw_logging

- name: Allow incoming traffic on authorized in ports
  block:
    - name: Get current UFW rules for incoming traffic on authorized in ports
      set_fact:
        current_ufw_incoming_ports: "{{ ufw_parsed.rules | selectattr('action_direction', 'equalto', 'IN') | selectattr('action', 'equalto', 'ALLOW') | list }}"

    - name: Add incoming traffic rules if not present
      ufw:
        rule: allow
        from_ip: "{{ item.from_ip | default('any') }}"
        to_port: "{{ item.to_port | default(None) }}"
        proto: "{{ item.proto }}"
        to_ip: "{{ item.to_ip | default('any') }}"
        from_port: "{{ item.from_port | default(None) }}"
        direction: in
      with_items: "{{ incoming_rules }}"
      when: not ansible_check_mode and (
        not item.to_port in ( 
        current_ufw_incoming_ports | 
        selectattr('from_ip', 'eq', item.from_ip) | 
        selectattr('to_transport', 'eq', item.proto) | 
        map(attribute='to_ports') | 
        flatten ))

    - name: Delete incoming traffic rules if present in current configuration but not in incoming_rules
      ufw:
        rule: delete
        from_ip: "{{ item.0.from_ip | default('any') }}"
        to_port: "{{ item.1 }}"
        proto: "{{ item.0.proto }}"
        direction: in
      with_subelements:
        - "{{current_ufw_incoming_ports}}"
        - to_ports
        - flags:
            skip_missing: true
      when: not ansible_check_mode and (
        item.0.from_ip in incoming_rules | map(attribute='from_ip') | list and
        item.0.to_transport in incoming_rules | map(attribute='proto') | list and
        item.1 not in incoming_rules | map(attribute='to_port') | list)

- name: Allow all traffic for whitelisted ips
  block:
    - name: Get the current UFW rules for whitelisted IPs
      set_fact:
        current_ufw_whitelisted_ips: "{{ ufw_parsed.rules | selectattr('action', 'equalto', 'ALLOW') | map(attribute='to_ip') | list }}"
      
    - name: Add whitelisted IPs if not present
      ufw:
        rule: allow
        src: "{{ item }}"
      with_items: "{{ incoming_rules }}"
      when: not ansible_check_mode and item not in current_ufw_whitelisted_ips

- name: Allow outgoing traffic on authorized out ports
  block:
    - name: Get current UFW rules for outgoing traffic on authorized out ports
      set_fact:
        current_ufw_outgoing_ports: "{{ ufw_parsed.rules | selectattr('action_direction', 'equalto', 'OUT') | selectattr('action', 'equalto', 'ALLOW') | list }}"
    
    - name: Add outgoing traffic rules if not present
      ufw:
        rule: allow
        to_ip: "{{ item.to_ip | default ('any') }}"
        to_port: "{{ item.to_port | default (None) }}"
        proto: "{{ item.proto }}"
        from_ip: "{{ item.from_ip | default ('any') }}"
        from_port: "{{ item.from_port | default (None) }}"
        direction: out
      with_items: "{{ incoming_rules }}"
      when: not ansible_check_mode and item not in current_ufw_outgoing_ports

    - name: Remove outgoing traffic rules not in playbook values
      ufw:
        rule: "delete allow to_ip={{ item.to_ip | default ('any') }} to_port={{ item.to_port | default (None) }} proto={{ item.proto }} from_ip={{ item.from_ip | default ('any') }} from_port={{ item.from_port | default (None) }} direction=out"
      with_items: "{{ current_ufw_outgoing_ports }}"
      when: not ansible_check_mode and item not in incoming_rules

- name: Add advanced ufw before rules
  blockinfile: dest=/etc/ufw/before.rules insertbefore="COMMIT" state=present block="{{ advanced_ufw_before_rules }}"
  when: not ansible_check_mode

- name: Add advanced ufw after rules
  blockinfile: dest=/etc/ufw/after.rules insertbefore="COMMIT" state=present block="{{ advanced_ufw_after_rules }}"
  when: not ansible_check_mode

- name: Drop all inputs ipv4
  lineinfile: dest=/etc/ufw/after.rules insertbefore="COMMIT" state=present line="-A ufw-reject-input -j DROP"
  when: "{{root_nbd}} and not ansible_check_mode"

- name: Drop all inputs ipv6
  lineinfile: dest=/etc/ufw/after6.rules insertbefore="COMMIT" state=present line="-A ufw6-reject-input -j DROP"
  when: "{{root_nbd}} and not ansible_check_mode"

- name: Allow all outgoing traffic
  ufw: policy=allow direction=outgoing
  when: not ansible_check_mode

- name: Deny or Allow all incoming traffic
  ufw: policy={{ root_nbd | ternary('allow','deny') }} direction=incoming
  when: not ansible_check_mode

# Ensure no iptable-persitent, as its handled by ufw
- name: Install iptables-persistent if necessary
  apt: name=iptables-persistent state=absent

- name: Enable firewall
  ufw: state=enabled
  when: not ansible_check_mode
